'''@app.route('/api/patient_history', methods=['GET'])
def api_patient_history():
    import re
    search_term = request.args.get('search_term', '').strip()
    db = connect_db()

    if not search_term:
        return jsonify({"error": "Search term is required"}), 400

    if db is None:
        return jsonify({"error": "Database connection error"}), 500

    cursor = db.cursor(dictionary=True)

    try:
        # Check if the search_term is numeric (for patientID)
        if re.match(r'^\d+$', search_term):
            # Search by patientID
            query = "SELECT * FROM patients WHERE patientID = %s"
            cursor.execute(query, (search_term,))
        else:
            # Search by patientName
            query = "SELECT * FROM patients WHERE patientName LIKE %s"
            cursor.execute(query, (f"%{search_term}%",))

        patient = cursor.fetchone()

        if patient:
            patient_id = patient['patientID']

            # Fetch appointments for the patient
            cursor.execute("SELECT * FROM appointments WHERE patientID = %s", (patient_id,))
            appointments = cursor.fetchall()

            # Fetch medical records for the patient
            cursor.execute("SELECT * FROM medical_records WHERE patientID = %s", (patient_id,))
            medical_records = cursor.fetchall()

            return jsonify({
                "patient": patient,
                "appointments": appointments,
                "medical_records": medical_records
            })
        else:
            return jsonify({"error": "Patient not found"}), 404

    except mysql.connector.Error as e:
        print(f"Database error: {e}")
        return jsonify({"error": "Database error occurred", "details": str(e)}), 500

    finally:
        cursor.close()
        db.close()'''

# @app.route('/search_patient_details', methods=['POST'])
# def search_patient_details():
#     search_term = request.form.get('search_term')
    
#     cur = mysql.connection.cursor()
    
#     # Search in patients table
#     cur.execute("""
#         SELECT * FROM patients 
#         WHERE patientID = %s OR patientName LIKE %s
#     """, (search_term, f'%{search_term}%'))
    
#     patient = cur.fetchone()
    
#     if patient:
#         patient_id = patient[0]  # Assuming patientID is the first column
        
#         # Get appointments
#         cur.execute("""
#             SELECT appointments.*, doctors.doctorName 
#             FROM appointments 
#             LEFT JOIN doctors ON appointments.doctorID = doctors.doctorID 
#             WHERE appointments.patientID = %s
#         """, (patient_id,))
#         appointments = cur.fetchall()
        
#         # Get medical records
#         cur.execute("""
#             SELECT * FROM medical_records 
#             WHERE patientID = %s
#         """, (patient_id,))
#         medical_records = cur.fetchall()
        
#         return render_template('_patient_details.html', 
#                              patient=patient,
#                              appointments=appointments,
#                              medical_records=medical_records)
    
#     return "<p>No patient found.</p>"

'''@app.route('/allocate_resource', methods=['POST'])
def allocate_resource():
    db = connect_db()
    cursor = db.cursor()
    patient_id = request.form.get('patientId')
    resource_id = request.form.get('resourceType')
    quantity = request.form.get('quantity')
    request_date = request.form.get('requestDate')

    try:
        cursor.execute("""
            INSERT INTO patients_resources (patientID, resource_id, quantity, request_date, status)
            VALUES (%s, %s, %s, %s, 'Allocated')
        """, (patient_id, resource_id, quantity, request_date))
        db.commit()
        flash("Resource allocated successfully!", "success")
    except mysql.connector.Error as e:
        db.rollback()
        flash(f"Error allocating resource: {str(e)}", "error")
    finally:
        cursor.close()
        db.close()

    return redirect(url_for('manage_resources'))

@app.route('/return_resource', methods=['POST'])
def return_resource():
    db = connect_db()
    cursor = db.cursor()

    return_patient_id = request.form.get('returnPatientId')
    return_resource_id = request.form.get('returnResourceType')
    return_quantity = request.form.get('returnQuantity')
    return_date = request.form.get('returnDate')

    try:
        cursor.execute("""
            UPDATE patients_resources
            SET status = 'Returned', returned_date = %s, quantity = quantity - %s
            WHERE patientID = %s AND resource_id = %s AND status = 'Allocated'
        """, (return_date, return_quantity, return_patient_id, return_resource_id))
        db.commit()
        flash("Resource returned successfully!", "success")
    except mysql.connector.Error as e:
        db.rollback()
        flash(f"Error returning resource: {str(e)}", "error")
    finally:
        cursor.close()
        db.close()

    return redirect(url_for('manage_resources'))

@app.route('/manage_resources', methods=['GET'])
def manage_resources():
    db = connect_db()
    cursor = db.cursor(dictionary=True)

    try:
        cursor.execute("SELECT * FROM patients_resources")
        resources = cursor.fetchall()
    except mysql.connector.Error as e:
        flash(f"Error retrieving resources: {str(e)}", "error")
        resources = []
    finally:
        cursor.close()
        db.close()

    return render_template('resources.html', patients_resources=resources)'''

    # @app.route('/api/doctors', methods=['GET'])
# def get_doctors():
#     # Ensure no limit is set here
#     doctor_records = doctors.query.all()  # Fetch all records
#     return jsonify([doctor.to_dict() for doctor in doctor_records])  # Convert to JSON

    # try:
    #     cursor.execute("SELECT prescription FROM medical_records WHERE recordID = %s", (record_id,))
    #     record = cursor.fetchone()
    #     if record and record['prescription']:
    #         app.logger.info(f"Serving prescription file: {record['prescription']}")
    #         return send_from_directory(app.config['UPLOAD_FOLDER'], record['prescription'])
    #     else:
    #         flash("Prescription not found", "error")
    #         return redirect(url_for('medical_records'))
    # except mysql.connector.Error as e:
    #     flash(f"Error retrieving prescription: {str(e)}", "error")
    #     return redirect(url_for('medical_records'))
    # finally:
    #     cursor.close()
    #     db.close()

# Appointment scheduling page
# 


# Hospital staff page
'''@app.route('/hospital_staff')
def hospital_staff():
    db = connect_db()
    if db is None:
        flash("Database connection error", "error")
        return redirect(url_for('index'))
    try:
        cursor = db.cursor(dictionary=True)
        cursor.execute("SELECT * FROM hospital_staff")
        hospital_staff = cursor.fetchall()
        cursor.close()
        db.close()
        return render_template('hospital_staff.html', hospital_staff=hospital_staff)
    except Exception as e:
        return f"Error :{e}"

# Add hospital staff
@app.route('/add_staff', methods=['POST'])
def add_staff():
    data = request.get_json()
    staffID = data.get('staffID')
    staffName = data.get('staffName')
    staff_role = data.get('staff_role')
    userName = data.get('userName')
    password = data.get('password')  # Make sure to hash the password before storing
    Contact = data.get('Contact')
    email = data.get('email')

    # Debugging information
    print(f"Received data: {data}")

    try:
        cursor = mysql.connection.cursor()
        cursor.execute("""
            INSERT INTO hospital_staff (staffID, staffName, staff_role, userName, password, Contact, email)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (staffID, staffName, staff_role, userName, password, Contact, email))
        mysql.connection.commit()
        cursor.close()
        return flash(f"Staff info added successfully")
    except Exception as e:
        print(f"Error: {str(e)}")  # Debugging information
        return flash(f"Staff info not added ")

# Search hospital staff
@app.route('/search_hospital_staff', methods=['GET'])
def search_hospital_staff():
    query = request.args.get('query', '')
    db = connect_db()  # Ensure this returns a valid database connection
    if db is None:
        return jsonify({'error': 'Database connection error'}), 500

    cursor = db.cursor(dictionary=True)

    try:
        print(f"Searching for staff with query: {query}")  # Debugging log
        cursor.execute("""
            SELECT * FROM hospital_staff
            WHERE staffName LIKE %s OR staff_role LIKE %s
        """, (f"%{query}%", f"%{query}%"))
        staff_members = cursor.fetchall()

        # Log the search results for debugging
        print(f"Found {len(staff_members)} staff members matching the query.")

        return jsonify(staff_members)

    except Exception as e:
        return jsonify({'error': str(e)}), 500

    finally:
        cursor.close()
        db.close()'''


        # app = Flask(__name__)
# app.secret_key = 'secret_key'
## For using SQL CLOUD where data is transfered between 2 devices
# class AppointmentDashboard:
#     def __init__(self):
#         try:
#             self.connection = pymysql.connect(
#                 host="mysql-15e34b52-haider-27c2.e.aivencloud.com",
#                 port=21375,
#                 user="avnadmnb",
#                 password="AVNS_tATmpo55a8IvGsimMD9",
#                 database="defaultdb",
#                 charset="utf8mb4",
#                 cursorclass=pymysql.cursors.DictCursor
#             )
#             logger.info("Successfully connected to the database")
#         except Exception as e:
#             logger.error(f"Error connecting to database: {e}")
#             raise

#     def get_all_appointments(self):
#         """Retrieve all appointments with their details"""
#         try:
#             with self.connection.cursor() as cursor:
#                 cursor.execute("""
#                     SELECT * FROM appointments 
#                     ORDER BY created_at DESC
#                 """)
#                 appointments = cursor.fetchall()
#                 return appointments
#         except Exception as e:
#             logger.error(f"Error retrieving appointments: {e}")
#             return []

# # Create the dashboard instance
# dashboard = AppointmentDashboard()  # Create the dashboard instance